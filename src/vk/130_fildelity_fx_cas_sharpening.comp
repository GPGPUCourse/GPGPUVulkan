/*
AMD FidelityFX Contrast Adaptive Sharpening
https://gpuopen.com/fidelityfx-cas/
https://www.shadertoy.com/view/ftsXzM
Potentially useful to upscale under-resolution renders.

This is a slimmed down reimplementation based on the paper.

Best viewed in fullscreen.
Drag left right to change switchover position. CAS on left.
Drag up and down to set CAS level.
*/

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;
    vec2 muv;
    if (iMouse.z > 0.) {
        muv = iMouse.xy/iResolution.xy;
    } else {
        muv = vec2(.5+.3*sin(iTime*.3),.5);
    }
  
    // Time varying pixel color
    vec3 col = texture(iChannel0, uv).xyz;

    // CAS algorithm
    float max_g = col.y;
    float min_g = col.y;
    vec4 uvoff = vec4(1,0,1,-1)/iChannelResolution[0].xxyy;
    vec3 colw;
    vec3 col1 = texture(iChannel0, uv+uvoff.yw).xyz;
    max_g = max(max_g, col1.y);
    min_g = min(min_g, col1.y);
    colw = col1;
    col1 = texture(iChannel0, uv+uvoff.xy).xyz;
    max_g = max(max_g, col1.y);
    min_g = min(min_g, col1.y);
    colw += col1;
    col1 = texture(iChannel0, uv+uvoff.yz).xyz;
    max_g = max(max_g, col1.y);
    min_g = min(min_g, col1.y);
    colw += col1;
    col1 = texture(iChannel0, uv-uvoff.xy).xyz;
    max_g = max(max_g, col1.y);
    min_g = min(min_g, col1.y);
    colw += col1;
    float d_min_g = min_g;
    float d_max_g = 1.-max_g;
    float A;
    if (d_max_g < d_min_g) {
        A = d_max_g / max_g;
    } else {
        A = d_min_g / max_g;
    }
    A = sqrt(A);
    A *= mix(-.125, -.2, muv.y);
    vec3 col_out = (col + colw * A) / (1.+4.*A);
    if (uv.x > (muv.x-.002)) {
        if (uv.x > (muv.x+.002)) {
            col_out = col;
        } else {
            col_out = vec3(0);
        }
    }
    // Output to screen
    fragColor = vec4(col_out,1);
}